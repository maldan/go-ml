+ goson должен использовать общие типы и являться лишь контейнером для хранения в БД
+ обертка для хранения данных должна быть одна для всех
+ каждый тип должен иметь методы запаковки и распаковки
+ каждый тип должен иметь маппер

+ переделать имя на ид, хранить карту ид в хедере файла
+ добавление
+ ремаппинг при добавлении

+ удаление
+ изменение
+ изменение одного поля
+ изменение нескольких полей
+ если данные не влазят в ячейку, делать реаллок
+ авто инкремент
- обновление без реаллока
- выравнивание по заданному размеру

+ поиск
- дата время со строки переделать в свой формат
- реплика на диск
- реплика по ссш

- буффер для записи

+ вернуть 2 байтовую пометку записи
+ при повреждение таблицы, скипать поврежденные участки
+ обновление сделать вместе с поиском, чтобы это было атомарной операцией
+ при обновлении, сначала добавление новой записи, а потом удаление старой

# Заметки

Удаление и обновление должны быть по условию. До этого я делал поиск записей, получал о них инфу.
Затем у инфы вызывал метод Update. Так нельзя. Потому что если 2 потока найдут запись и начнут ее
обновлять, это в итоге создаст в базе 2 новые записи.

Нужно найти инфу, а потом вызывать метод апдейт по условию. Например, userId==2. И передать поля, которые
надо изменить. В этом случае update заблокирует поток до тех пока не обновит инфу. И если 2 потока
одновременно вызовут update то даже если 1й поток создаст новую запись. То второй поток потом
найдет именно созданную новую запись и обновит ее еще раз.

# Ошибки и их обработка

Частичная запись в таблицу
+ игнорировать и пропускать поломанные блоки при чтении

При распаковке структуры в случае несовпадения типов полей
- игнорировать, в лучшем случае пытаться кастовать.
- например был инт, стал флоат. Или было число, стало строкой. "2" превращается в 2 и наоборот.

Если не найдено название поля в таблице idToName
- игнорировать, выводить в консоль варнинг